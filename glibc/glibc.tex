
\section{Linux Kernel, Glibc, and Tools Problems}

The problems of adopting PiP will be discussed in this section. 

\subsection{Loading a Program}

Readers should have a basic understanding of how programs are loaded
into memory before reading more in-depth about the Glibc difficulties
when implementing PiP. Except the PiP technology, this paragraph only
discusses the Linux application loading process.

When a program is launched on Linux using the \linuxfunc{execve}
system call, the Linux kernel opens and reads the executable file
while looking for the "{\tt .interp}" ELF section.

\lstinputlisting[style=example, basicstyle=\tiny\tt, 
  caption={{\tt .interp} Section of the {\tt ps} command},
  label=out:interp] {glibc/examples/interp.out}

The value of the {\tt .interp} section, /lib64/ld-linux-x86-64.so, is
displayed in Listing~\ref{out:interp}. To load a program supplied by
the \linuxfunc{execve} argument, the Linux kernel invokes the loader
specified by the {\tt .interp} section.
The program is then loaded by the loader, along with the shared
libraries needed to run it. The loader then calls the user-specified
\main/ function after Glibc has been initialized by the starting
function defined in Glibc.

Once per address space, the program loader, which is frequently
referred to as {\tt ld-linux.so}, is loaded and held in memory until
the process finishes (see also Listing~\ref{out:maps}). By resolving
external symbol references, it is in charge of any loading
procedure. The Glibc functions, such as \linuxfunc{dlopen},
\linuxfunc{dlmopen}, \linuxfunc{dlsym}, and others, defined in the
{\tt libdl.so} ({\tt -ldl}), are only API, and this program
loader contains their functional bodies.

\subsection{Glibc}

PiP offers a novel execution model that defies classification as
either a process model or a thread model. While the name of this new
model has not yet been revealed, tasks in it maintain variable
privatization similar to the process model while sharing the same
address space as threads. The majority of the tool chains offered by
Linux and others do not yet understand this execution style because it
is new. In fact, the majority of the work spent developing PiP was
spent trying to locate Glibc niches. 

\subsubsection{PiP Task is Unable to Spawn PiP Task}

The sequence in which \linuxfunc{dlmopen} and \linuxfunc{clone} are
called matters, as discussed in Section~\ref{sec:rationale}. Due to
this restriction, a PiP task cannot launch another PiP task as a child
task because doing so violates the constraint. As a result, calling
\pipfunc{pip_task_spawn} or \pipfunc{pip_spawn} from a PiP task is
prevented by the present PiP implementation. 

\subsubsection{Recycling PiP Tasks}\label{sec:recycle}

According to my testing, calling the \linuxfunc{dlclose} function does
not release the name space, loaded PIE application, or shared
libraries used by the PIE program. I think fixing the Gilbc might
solve this problem, but I've chosen against it. Hence, even if a PiP
task ends after being established, the task's \PIPID\ will not be
recycled. The rationale for my choice will also be covered in
Section~\ref{sec:retrive}. 

\subsubsection{Number of name spaces}\label{sec:name-space}

The hard-coded limit for the number of names spaces that
\linuxfunc{dlmopen} can create is 16. This number of 16 appears to be
inadequate when taking into account the parallel execution of PiP jobs
and the current CPU core count. The PiP package offers \pipglibc,
which offers up to 300 PiP tasks and more name spaces\footnote{Once I
  asked Glibc development members to increae the size, but they did
  not accept my opinion. Refer
  \url{https://sourceware.org/bugzilla/show_bug.cgi?id=23978}}.

As the name space table is located in the {\tt ld-linux.so}, PiP
programs' {\tt .interp} ELF section needs to be modified in order for
the program to be loaded by the patched {\tt ld-linux.so}. The GNU
linker's {\tt \dash2{}dynamic-linker} option can be used to accomplish this,
and the \pipcmd{pipcc} and \pipcmd{pipfc} do this.

In {\tt ld-linux.so}, the name space table is found at the top of a
structure. A few Glibc internal functions make direct references to the
structure's members. This results in yet another issue. The addresses
of the other members of this structure are likewise updated once
the name space table's size is altered. One {\tt ld-linux.so} can only
be loaded at a time in an address space, as stated. As a result, the same
Glibc must be associated with each PiP program sharing the same
address.

\subsubsection{\pipgdb}

The loaded application has information for debugging that is embedded
by the {\tt ld-linux.so} file. Unfortunately, I discovered that this
code fragment is located on the pass that the kernel uses to call
ld-linux.so, not on the pass that was called from \linuxfunc{dlopen}
and \linuxfunc{dlmopen}. This problem was fixed with the \pipglibc\,
the patched Glibc. As a result, only PiP applications linked with
\pipglibc\ can be used with the \pipcmd{pip-gdb} command
(Section~\ref{sec:pip-gdb}).  

\subsubsection{Global lock}

The majority of programs, including PiP programs, are linked using
Glibc. Several PiP programs can execute simultaneously in the same
address space thanks to PiP. As a result, every PiP task has a unique
Glibc. Moreover, a race condition may prevent several Glibc functions
from working when called simultaneously.  

PiP library offers the routines \pipfunc{pip_glibc_lock} and
\pipfunc{pip_glibc_unlock} to serialize the Gilbc function calls in
order to prevent this situation. The PiP library wraps the following
Glibc routines so that the lock can be introduced and users don't have
to worry about the race.

\begin{table}[ht]
  \centering
  \caption{Glibc functions wrapped by PiP library}\label{tbl:pip-wrapper}
  \vspace{3mm}
  \tt
  \begin{tabular}{lll}
    \hline
    dlsym	&
    dlopen	&
    dlmopen	\\
    dlinfo	&
    dlclose	&
    dlerror	\\
    dladdr	&
    dlvsym	&
    getaddrinfo	\\
    freeaddrinfo &
    gai_strerror &
    pthread_create \\
    \hline
    pthread_exit \\
    \hline
    malloc 	&
    free	&
    calloc	\\
    realloc	&
    memalign 	&
    posix_memalign \\
    \hline
  \end{tabular}
\end{table}

This table's functions \linuxfunc{pthread_exit} and below have
function wrappers for still another reason. The malloc functions will
be wrapped for the reasons that will be explained in
Section~\ref{sec:malloc}, and \linuxfunc{pthread_exit} will 
be wrapped for the reasons that will be explained in
Section~\ref{sec:exec-mode}. 

These stated functions might not be all of them. Other Glibc functions
may experience the race condition in some circumstances. The
aforementioned locking functions can be added to eliminate this
issue. Users can easily prevent deadlock situations by using this lock
in a recursive fashion.

\subsubsection{Constructors and Destructors}

Programs written in C++ employ constructors and
destructors. Destructor functions are typically called as the program
is about to end, whereas constructor functions are typically called
right before the program starts.  

The behavior of the constructors and destroyers differs slightly in
PiP. I should begin by describing the generic implementation of
constructors and destructors in order to clarify this. The {\tt
  .init_array} section of an ELF file contains a list of the
constructor functions. The {\tt .fini_array} section contains a list
of the destructor functions. When {\tt ld-linux.so} has finished
loading and linking objects, constructors are called. When
\linuxfunc{_exit} or \linuxfunc{dlclose} is called, destructors are
invoked. 

Back to PiP now. When starting a PiP process, constructors are once
more called inside of the \linuxfunc{dlmopen} call. The PiP root
process calls the \linuxfunc{dlmopen} function. Hence, the root of a
program calls the constructors. Here is the example;

\lstinputlisting[style=program,
  caption={Constructors and Destructors},
  label=prg:const-dest] {glibc/examples/hello.cpp}

A C++ program with a constructor and destructor is shown in
Listing~\ref{prg:const-dest}. The PiP library has not yet been
initialized when the constructor of this program is invoked, and
\pipfunc{pip_get_pipid} returns an error ({\tt EPERM}). Hence, the
{\tt pipidstr()} function handles this circumstance. The 
executable example of this program is shown in
Listing~\ref{out:const-dest}. As can be seen, the PIDs produced by the
constructors differ from those of the PiP tasks.

\lstinputlisting[style=example, 
  caption={Constructors and Destructors - Execution},
  label=out:const-dest] {glibc/examples/hello.out}

\subsubsection{{\tt LD_PRELOAD}}

PiP tasks cannot be used with \linuxenv{LD_PRELOAD}; only PiP root
may. This is due to the fact that dlmopen() flatly disregards the
\linuxenv{LD_PRELOAD} environment variable.

\subsubsection{Shared Objects}

Certain shared objects, including runtime libraries related to GCC,
need to be in the same directory as the {\tt ld-linux.so}. To adhere
to the  restriction, the \pipglibc\ package's \pipcmd{piplnlibs} shell
script creates symbolic links of the shared objects in the {\tt
  /lib64} directory. 

\subsubsection{Loading Program by {\tt dlmopen}}

A PIE program cannot be loaded using the \linuxfunc{dlmopen} function
in CentOS/RedHat 8 (or maybe newer ones)\footnote{Refer
\url{https://sourceware.org/bugzilla/show_bug.cgi?id=11754\#c15}}. This
Glibc restriction is to be circumvented via the \pipcmd{pip-unpie}
tool. Instead of being called directly by users, this program is run
automatically by the \pipcmd{pipcc} or \pipcmd{pipfc} when a PiP
executable is created. 

\subsection{Glibc {\tt RPATH} Setting}

Every program, including PiP, has its {\tt RPATH}s added automatically
when using Spack\footnote{\url{https://spack.io}}. While using Spack
to install PiP-glibc, an issue occurs. Spack adds the {\tt RPATH}
value to the compiled \pipglibc\, but loading Glibc with the {\tt
  RPATH} setting is not allowed in CentOS/Redhat 8. \pipglibc\ has a
program (\pipcmd{annul_rpath}) to unset the {\tt RPATH} setting of the
\pipglibc\ that has been built in order to prevent this. 

\subsection{Linux}

\subsubsection{Heap Segment}\label{sec:heap}

There is another issue which comes from Linux kernel, not from
Glibc. Before explaining this issue, let us start from the how an
address space is composed. 

\lstinputlisting[style=example, basicstyle=\tiny\tt, 
  caption={A Memory Map Example},
  label=out:maps] {glibc/examples/maps.out}

Listing~\ref{out:maps} shows an example of the output of doing ``{\tt
  cat /proc/\option{PID}/maps}.'' Here, ``{\tt pip-exec -n 2
  ./a.out}'' was executed, resulting one \pipcmd{pip-exec} process
and two {\tt ./a.out} tasks. The file, {\tt
  /proc/\option{PID}/maps}, lists all memory
segments in an address space of the process \option{PID}
usually. A loaded shared object has consecutive three or four segments; 
executable, gap (not accessible, if any), constants and data. 
The rightmost column of a line indicates the {\tt
  mmap()}ed filename, the second from the left column indicates the
permission of the memory segment. '{\tt r}' is readable, '{\tt w}' is
writable, '{\tt x}' is executable and '{\tt p}' is private
(copy-on-write). There are also some special segments whose filename
is in a pair of square brackets; {\tt [stack]}, {\tt [heap]}, and so
on. These are created by the Linux kernel for special purposes as
their names suggest. The segments having no filename are created by
the \linuxfunc{mmap} system call. 

Remember, this is the address space of running one PiP root and two PiP
tasks, resulting to have all the segments of the three tasks.
Note that the all three tasks have
exactly the same {\tt /proc/\option{PID}/maps} content, and
there are three sets of a shared library and only one set of {\tt
  ld-linux.so} ({\tt ld-2.28.so}) can be seen in
Listing~\ref{out:maps}.

Usually, the heap segment, mainly used by \linuxfunc{malloc}, exists only
one per address space. As shown in this example, there is only one heap
segment, meaning the heap segment is shared by three tasks (one for
root and two for PiP tasks). 

The size of the heap segment can be increased or decreased by calling
the \linuxfunc{brk} system call. Most cases, there are two calls of
\linuxfunc{brk} to allocate or deallocate heap memory, one for
obtaining the 
current heap end address and another for setting the new heap end 
address. This is exactly what the Glibc's \linuxfunc{sbrk}
does. Apparently, this API is not thread-safe at all, and thus, 
the shared heap memory cannot be used safely by PiP tasks.

Fortunately, the \linuxfunc{malloc} routines in Glibc is designed to check if
there are two or more name spaces and if so they do not use the
\linuxfunc{brk} system call, use {\tt mmap()} instead. So, the Glibc
\linuxfunc{malloc} routines can work with PiP without any
problem. However, if some other routines use the \linuxfunc{brk}
system call (or \linuxfunc{sbrk} Glibc function), for example,
replacing the Glibc \linuxfunc{malloc} routines with some other
\linuxfunc{malloc} implementation, then this shared heap may result in a 
problem.

\subsubsection{Core File}

Suppose that we have a catastrophic situation and all PiP tasks and
their root process dump core files of their own. On the current Linux,
a core file is associated with a process (including threads inside of
it). Thus, each PiP task and the root may produce core, resulting to
have many core files. Here, the address space of them are shared and
the created core files and all of them are almost the same excepting
the CPU state. 

Let me explain this with an example. Suppose that we have PiP task $A$
and $B$ running on the same address space of the root $P$, and an
error happens resulting all $P$, $A$, and $B$ produce core
files. There can be a small time difference when to produce each core
file. When the first core file, of $A$ for instance, is being created,
the other $P$ and $B$ are still running and the memory of the shared 
address space can be altered by those running tasks.
\linuxcmd{gdb}, however, assumes that a core file is a consistent snapshot
of memory and CPU state. The above PiP situation breaks this
assumption. If $B$ produces another core file, may or may not be
caused by the error on $A$, the same situation can happen.
Thus, the \pipcmd{pip-gdb} command (Section~\ref{sec:pip-gdb}) does
not support for debugging from a core file. To solve this issue,
PiP-aware OS kernel to have the consistent core files is needed. 

\subsection{Tools}

As described, PiP sets a special combination of the \linuxfunc{clone}
flags. As a result of this, some tools do not work. Here is the list
of tools which are known to work or not at the time of this
writing\footnote{\linuxcmd{ltrace} depends on its version}. 

\begin{table}[ht]
  \centering
  \caption{Compatibility of Tools}
  \vspace{3mm}
  \begin{tabular}{c|c}
    \hline
    Compatible & Incompatible \\
    \hline
        {\tt strace} & {\tt valgrind} \\
        {\tt ltrace} \\
        \hline
  \end{tabular}
\end{table}
