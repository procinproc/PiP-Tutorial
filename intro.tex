
This document explains the PiP (short for Process-in-Process)
library. This library with a little odd name offers a relatively new
execution paradigm that combines the finest aspects of multi-process
and multi-threaded execution models.  

Multiple CPU cores in a CPU die or socket are becoming very common,
and a parallel execution environment is essential for maximizing the
capability of the many-core architecture.  
Despite accessing the same physical memory device, a process in the
multi-process model, where numerous processes run concurrently on a
node, cannot directly access data held by the other
processes. Processes typically communicate in order to exchange
information. In my opinion, all forms of data copying, whether carried
out by hardware or software, are a part of communication. Data copying
is energy-, memory-, and time-intensive and should be avoided if
possible. What if processes could access other people's data without
communicating with them first? In the multi-thread paradigm, static
variables are shared across threads, and if threads attempt to update
their values, race problems must be prevented. What if static
variables were private for each thread?

This is what drives me to develop PiP. As the name {\it
Process-in-Process} might imply, a process can spawn additional
processes inside of its own address space. This sounds like the
multi-thread execution model, but the name of the {\it process} in PiP
indicates that, unlike the multi-thread approach, each new process has
its own static variable set. As a result, while keeping the privatized
static variables, the created processes that share the same address
space can access data that belongs to the others. On this basis, data
copying and communication can be prevented.  

In essence, a multi-process model shares nothing, a multi-thread model
shares everything, and PiP's execution paradigm allows for everything
to be shareable.  

Regarding some of my forebears, different implementations exist that
offer this particular execution approach. PiP, however, stands out
since it is implemented entirely at the user-level and doesn't require
a new OS kernel, a patched OS kernel, or new language processing
systems.  

High performance computing (HPC) has been my area of focus, and I know
very little about the other disciplines. HPC applications are all I
can think of. But I think that PiP's usability can be extended to
other industries.
